#!/usr/bin/env python3

"""
Round-Robin HTTP Proxy with Health Monitoring
Polls backend servers every minute and routes to the healthiest one.
"""

import aiohttp
import asyncio
import json
import logging
import os
import time
from aiohttp import web, ClientTimeout
from dataclasses import dataclass, field
from typing import List, Optional
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Reduce aiohttp access log verbosity
logging.getLogger('aiohttp.access').setLevel(logging.WARNING)

@dataclass
class ServerHealth:
    url: str
    is_healthy: bool = False
    last_check: float = 0
    response_time: float = float('inf')
    consecutive_failures: int = 0
    last_error: Optional[str] = None

@dataclass
class ProxyConfig:
    servers: List[str] = field(default_factory=list)
    reference_addr: str = "localhost"
    server_key: str = "<get one please>"
    health_check_interval: int = 60  # seconds
    health_check_timeout: int = 5    # seconds
    proxy_host: str = "0.0.0.0"  # Public interface for client connections
    proxy_port: int = 8080
    management_host: str = "127.0.0.1"  # Management interface (localhost only)
    management_port: int = 8081
    max_consecutive_failures: int = 3
    max_request_size: int = 10 * 1024 * 1024  # 10MB default

class HealthMonitor:
    def __init__(self, config: ProxyConfig):
        self.config = config
        self.servers = [ServerHealth(url=url) for url in config.servers]
        self.session: Optional[aiohttp.ClientSession] = None
        self.current_server_index = 0

    async def start(self):
        """Initialize the health monitor"""
        timeout = ClientTimeout(total=self.config.health_check_timeout)
        self.session = aiohttp.ClientSession(timeout=timeout)

        # Start health checking task
        asyncio.create_task(self.health_check_loop())
        logger.info(f"Health monitor started for servers: {self.config.servers}")

    async def stop(self):
        """Clean up resources"""
        if self.session:
            await self.session.close()

    async def health_check_loop(self):
        """Continuously monitor server health"""
        while True:
            await self.check_all_servers()
            await asyncio.sleep(self.config.health_check_interval)

    async def check_all_servers(self):
        """Check health of all servers concurrently"""
        tasks = []

        payload = {'jsonrpc': '2.0', 'method': 'eth_blockNumber', 'params': [], 'id':1}
        main_url = f"https://{self.config.reference_addr}/ogrpc?network=ethereum&dkey={self.config.server_key}"

        try:
            logger.info(f"Checking {main_url}")
            async with self.session.post(main_url, json = payload) as response:
                if response.status == 200:
                    result = await response.json()
                    for server in self.servers:
                        task = asyncio.create_task(self.check_server_health(server, payload, int(result['result'], 16)))
                        tasks.append(task)

                    await asyncio.gather(*tasks, return_exceptions=True)
                    self.log_server_status()
        except Exception as e:
            pass

    async def check_server_health(self, server: ServerHealth, payload: dict, current_block: int):
        """Check health of a single server"""
        start_time = time.time()

        try:
            async with self.session.post(server.url, json = payload) as response:
                response_time = time.time() - start_time

                if response.status == 200:
                    result = await response.json()
                    node_block = int(result['result'], 16)
                    if current_block - node_block > 5:  # Allow a small lag
                        self.mark_server_unhealthy(server, f"Node lagging (block {node_block}, current {current_block})", immediate=True)
                        return
                    server.is_healthy = True
                    server.response_time = response_time
                    server.consecutive_failures = 0
                    server.last_error = None
                    logger.debug(f"Server {server.url} is healthy (response time: {response_time:.3f}s)")
                else:
                    self.mark_server_unhealthy(server, f"HTTP {response.status}")

        except Exception as e:
            self.mark_server_unhealthy(server, str(e))

        server.last_check = time.time()

    def mark_server_unhealthy(self, server: ServerHealth, error: str, immediate: bool = False):
        """Mark server as unhealthy and track failures

        Args:
            server: The server to mark unhealthy
            error: Error message
            immediate: If True, mark unhealthy immediately without waiting for threshold
        """
        server.consecutive_failures += 1
        server.last_error = error
        server.response_time = float('inf')

        if immediate or server.consecutive_failures >= self.config.max_consecutive_failures:
            server.is_healthy = False
            logger.warning(f"Server {server.url} marked as unhealthy: {error}")

    def get_best_server(self) -> Optional[ServerHealth]:
        """Get the healthiest available server"""
        healthy_servers = [s for s in self.servers if s.is_healthy]

        if not healthy_servers:
            logger.error("No healthy servers available!")
            return None

        # Sort by response time (ascending) to get the fastest healthy server
        healthy_servers.sort(key=lambda s: s.response_time)
        return healthy_servers[0]

    def get_next_server_round_robin(self) -> Optional[ServerHealth]:
        """Get next server using round-robin among healthy servers"""
        healthy_servers = [s for s in self.servers if s.is_healthy]

        if not healthy_servers:
            return None

        # Simple round-robin
        server = healthy_servers[self.current_server_index % len(healthy_servers)]
        self.current_server_index += 1
        return server

    def log_server_status(self):
        """Log current status of all servers"""
        healthy_count = sum(1 for s in self.servers if s.is_healthy)
        logger.info(f"Health check complete: {healthy_count}/{len(self.servers)} servers healthy")

        for server in self.servers:
            status = "‚úì" if server.is_healthy else "‚úó"
            rt = f"{server.response_time:.3f}s" if server.response_time != float('inf') else "N/A"
            error_info = f" ({server.last_error})" if server.last_error else ""
            logger.info(f"  {status} {server.url} - Response time: {rt}{error_info}")

class HTTPProxy:
    def __init__(self, config: ProxyConfig):
        self.config = config
        self.health_monitor = HealthMonitor(config)
        self.client_session: Optional[aiohttp.ClientSession] = None

    async def start_server(self):
        """Start both the proxy server and management server"""
        await self.health_monitor.start()

        # Create client session for proxying requests
        self.client_session = aiohttp.ClientSession()

        # Increase max payload size to 10MB (default is 2MB)
        proxy_app = web.Application(client_max_size=self.config.max_request_size)
        proxy_app.router.add_route('*', '/{path:.*}', self.proxy_handler)

        # Private management application (localhost only)
        mgmt_app = web.Application()
        mgmt_app.router.add_get('/health', self.health_status_handler)
        mgmt_app.router.add_post('/loglevel', self.set_loglevel_handler)

        # Start proxy server on public interface
        proxy_runner = web.AppRunner(proxy_app)
        await proxy_runner.setup()
        proxy_site = web.TCPSite(
            proxy_runner,
            self.config.proxy_host,
            self.config.proxy_port
        )
        await proxy_site.start()
        logger.info(f"Proxy server started on http://{self.config.proxy_host}:{self.config.proxy_port}")

        # Start management server on localhost only
        mgmt_runner = web.AppRunner(mgmt_app)
        await mgmt_runner.setup()
        mgmt_site = web.TCPSite(
            mgmt_runner,
            self.config.management_host,
            self.config.management_port
        )
        await mgmt_site.start()
        logger.info(f"Management server started on http://{self.config.management_host}:{self.config.management_port}")

        return (proxy_runner, mgmt_runner)

    async def health_status_handler(self, request: web.Request) -> web.Response:
        """Return current health status of all backend servers

        Example usage (management interface only):
            curl http://localhost:8081/health
        """
        servers_status = []
        for server in self.health_monitor.servers:
            servers_status.append({
                "url": server.url,
                "healthy": server.is_healthy,
                "response_time": server.response_time if server.response_time != float('inf') else None,
                "last_check": server.last_check,
                "consecutive_failures": server.consecutive_failures,
                "last_error": server.last_error
            })

        return web.json_response({
            "servers": servers_status,
            "healthy_count": sum(1 for s in self.health_monitor.servers if s.is_healthy),
            "total_count": len(self.health_monitor.servers)
        })

    async def set_loglevel_handler(self, request: web.Request) -> web.Response:
        """Dynamically change log level

        Example usage (management interface only):
            curl -X POST http://localhost:8081/loglevel -H "Content-Type: application/json" -d '{"level": "DEBUG"}'
            curl -X POST http://localhost:8081/loglevel -H "Content-Type: application/json" -d '{"level": "INFO", "logger": "aiohttp.access"}'
        """
        try:
            data = await request.json()
            level = data.get('level', '').upper()
            logger_name = data.get('logger', '__main__')  # Default to main logger

            # Validate level
            valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']
            if level not in valid_levels:
                return web.json_response({
                    "error": f"Invalid level. Must be one of: {', '.join(valid_levels)}"
                }, status=400)

            # Get the logger and set level
            target_logger = logging.getLogger(logger_name)
            target_logger.setLevel(getattr(logging, level))

            logger.info(f"Log level for '{logger_name}' changed to {level}")

            return web.json_response({
                "success": True,
                "logger": logger_name,
                "level": level
            })

        except Exception as e:
            return web.json_response({
                "error": str(e)
            }, status=400)

    async def proxy_handler(self, request: web.Request) -> web.Response:
        """Handle incoming requests and proxy them to a healthy backend"""
        # Get the best available server
        target_server = self.health_monitor.get_best_server()

        if not target_server:
            return web.Response(
                status=503,
                text="Service Unavailable: No healthy backend servers",
                content_type="text/plain"
            )

        # Build target URL
        path = request.path_qs
        target_url = f"{target_server.url.rstrip('/')}{path}"

        try:
            # Prepare headers (remove hop-by-hop headers)
            headers = dict(request.headers)
            hop_by_hop = {'connection', 'keep-alive', 'proxy-authenticate',
                         'proxy-authorization', 'te', 'trailers', 'upgrade'}
            headers = {k: v for k, v in headers.items()
                      if k.lower() not in hop_by_hop}

            # Forward the request
            async with self.client_session.request(
                method=request.method,
                url=target_url,
                headers=headers,
                data=await request.read(),
                allow_redirects=False
            ) as response:

                # Prepare response headers
                resp_headers = dict(response.headers)

                # Remove hop-by-hop headers AND content-encoding headers
                # because aiohttp automatically decompresses the body
                headers_to_remove = hop_by_hop | {'content-encoding', 'content-length'}
                resp_headers = {k: v for k, v in resp_headers.items()
                              if k.lower() not in headers_to_remove}

                # Handle streaming response properly
                if response.headers.get('Transfer-Encoding', '').lower() == 'chunked':
                    # For chunked responses, stream the content
                    resp = web.StreamResponse(
                        status=response.status,
                        headers=resp_headers
                    )
                    await resp.prepare(request)

                    async for chunk in response.content.iter_chunked(8192):
                        await resp.write(chunk)

                    await resp.write_eof()
                    return resp
                else:
                    # For regular responses, read the full body
                    body = await response.read()

                    # Ensure Content-Length is set correctly
                    resp_headers['Content-Length'] = str(len(body))

                    return web.Response(
                        status=response.status,
                        headers=resp_headers,
                        body=body
                    )

        except Exception as e:
            logger.error(f"Error proxying request to {target_url}: {e}")
            return web.Response(
                status=502,
                text=f"Bad Gateway: Error connecting to backend server",
                content_type="text/plain"
            )

    async def stop(self):
        """Clean up resources"""
        if self.client_session:
            await self.client_session.close()
        await self.health_monitor.stop()

async def main():
    # Configuration
    instances = os.environ['INSTANCES'].split(",")
    config = ProxyConfig(
        servers= list(map(lambda x: f"http://{x}:8545", os.environ['INSTANCES'].split(','))),
        reference_addr = os.environ['REFERENCE_ADDR'],
        server_key = os.environ['SERVER_KEY'],
        health_check_interval=60,  # Check every minute
        health_check_timeout=5,    # 5 second timeout for health checks
        proxy_host=os.environ['BIND_ADDR'],
        proxy_port=8545,
        management_host="127.0.0.1",  # Management API only on localhost
        management_port=8081
    )

    # Start the proxy
    proxy = HTTPProxy(config)

    try:
        proxy_runner, mgmt_runner = await proxy.start_server()

        print(f"üöÄ Proxy server running on http://{config.proxy_host}:{config.proxy_port}")
        print(f"üîß Management API running on http://{config.management_host}:{config.management_port}")
        print(f"üìä Monitoring servers: {config.servers}")
        print(f"üîç Health checks every {config.health_check_interval} seconds")
        print("\nManagement endpoints (localhost only):")
        print(f"  - Health status: curl http://{config.management_host}:{config.management_port}/health")
        print(f"  - Change log level: curl -X POST http://{config.management_host}:{config.management_port}/loglevel -H 'Content-Type: application/json' -d '{{\"level\": \"DEBUG\"}}'")
        print("\nPress Ctrl+C to stop...")

        # Keep the server running
        while True:
            await asyncio.sleep(1)

    except KeyboardInterrupt:
        logger.info("Shutting down...")
        await proxy.stop()
        await proxy_runner.cleanup()
        await mgmt_runner.cleanup()

if __name__ == "__main__":
    asyncio.run(main())
